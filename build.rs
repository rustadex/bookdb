use std::{env, fs, path::PathBuf};

// ============================================================================
// CONFIGURABLE PATH CONSTANTS
// ============================================================================

/// Base path for SQL files relative to project root
/// Change this one constant to relocate all SQL files
const SQL_BASE_PATH: &str = "src/bookdb/service/db/data";

/// You can also make this configurable via environment variable:
/// const SQL_BASE_PATH: &str = env!("BOOKDB_SQL_PATH", "src/bookdb/service/db/data");
/// Then set BOOKDB_SQL_PATH=src/sql in your environment to relocate

// ============================================================================
// BUILD FUNCTIONS
// ============================================================================

pub fn build_const_from_dir(src_dir: &PathBuf, out_path: &PathBuf, sql_version: &str, base_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut buf = String::new();

    // Add header comment to generated file
    buf.push_str(&format!(
        "// Generated SQL constants from: {}\n// SQL Version: {}\n// Generated by build.rs\n\n",
        src_dir.display(),
        sql_version
    ));

    let entries = fs::read_dir(&src_dir)?;
    let mut file_count = 0;

    for entry in entries {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) == Some("sql") {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            let stem = path.file_stem().unwrap().to_str().unwrap();

            // CONST NAME: uppercase + non-alnum -> _
            let const_name: String = stem.chars()
                .map(|c| if c.is_ascii_alphanumeric() { c.to_ascii_uppercase() } else { '_' })
                .collect();

            // Use configurable base path instead of hardcoded path
            let include_path = format!("{}/{}/{}", base_path, sql_version, file_name);

            // emit: pub const RESOLVE_PROJECT_ID: &str = include_str!("src/bookdb/service/db/data/sqlv2/resolve_project_id.sql");
            buf.push_str(&format!(
                "pub const {}: &str = include_str!(\"{}\");\n",
                const_name, include_path
            ));
            
            file_count += 1;
        }
    }

    fs::write(&out_path, buf)?;
    println!("cargo:warning=Generated {} SQL constants from {}", file_count, src_dir.display());
    
    Ok(())
}

/// Get SQL version from Cargo.toml with better error handling
fn get_sql_version(cargo_toml: &str) -> Result<String, Box<dyn std::error::Error>> {
    let doc: toml::Value = toml::from_str(cargo_toml)?;
    
    let sql_version = doc
        .get("package").and_then(|p| p.get("metadata"))
        .and_then(|m| m.get("sql")).and_then(|s| s.get("version"))
        .and_then(|v| v.as_str())
        .unwrap_or("sqlv2"); // default if missing

    Ok(sql_version.to_string())
}

/// Set up rebuild triggers for proper incremental builds
fn setup_rebuild_triggers(sql_dir: &PathBuf, _sql_version: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.toml");
    
    // Watch the SQL directory
    if sql_dir.exists() {
        println!("cargo:rerun-if-changed={}", sql_dir.display());
        
        // Watch individual SQL files for more precise rebuilds
        for entry in fs::read_dir(&sql_dir)? {
            let path = entry?.path();
            if path.extension().and_then(|s| s.to_str()) == Some("sql") {
                println!("cargo:rerun-if-changed={}", path.display());
            }
        }
    } else {
        println!("cargo:warning=SQL directory not found: {}", sql_dir.display());
    }

    Ok(())
}

// ============================================================================
// MAIN BUILD LOGIC
// ============================================================================

fn main() -> Result<(), Box<dyn std::error::Error>> {


    // Skip build script for tests
    // if std::env::var("CARGO_CFG_TEST").is_ok() {
    //     println!("cargo:warning=Skipping build script for tests");
    //     return Ok(());
    // }

    // ----- Read Cargo.toml -----
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let cargo_toml = fs::read_to_string(manifest_dir.join("Cargo.toml"))?;

    // ----- Parse SQL version from [package.metadata.sql] -----
    let sql_version = get_sql_version(&cargo_toml)?;
    println!("cargo:warning=Using SQL version: {}", sql_version);

    // Make the SQL version available in code
    println!("cargo:rustc-env=SQL_VERSION={}", sql_version);

    // ----- Build paths using configurable base -----
    let sql_dir = manifest_dir.join(SQL_BASE_PATH).join(&sql_version);
    let out_path = PathBuf::from(env::var("OUT_DIR")?).join("sql_consts.rs");

    println!("cargo:warning=Looking for SQL files in: {}", sql_dir.display());

    // ----- Generate constants -----
    if sql_dir.exists() {
        build_const_from_dir(&sql_dir, &out_path, &sql_version, SQL_BASE_PATH)?;
        println!("cargo:rerun-if-changed=src/bookdb/service/db/data/sqlv2");
        println!("cargo:rerun-if-changed=src/bookdb/service/db/data/sqlv1");
    } else {
        // Generate fallback constants if directory doesn't exist
        generate_fallback_constants(&out_path, &sql_version)?;
        println!("cargo:warning=SQL directory not found, using fallback constants");
    }
    



    // ----- Set up rebuild triggers -----
    setup_rebuild_triggers(&sql_dir, &sql_version)?;

    println!("cargo:warning=Build completed successfully");
    Ok(())
}

// ============================================================================
// FALLBACK CONSTANTS FOR MISSING SQL FILES
// ============================================================================

fn generate_fallback_constants(out_path: &PathBuf, sql_version: &str) -> Result<(), Box<dyn std::error::Error>> {
    let fallback_content = format!(
        "// Fallback SQL constants generated by build.rs\n\
         // SQL Version: {}\n\
         // Generated because SQL directory was not found\n\
         \n\
         pub const V1_CREATE_TABLES: &str = \"\
         -- Basic schema for BookDB\\n\
         CREATE TABLE IF NOT EXISTS project_ns (\\n\
             id INTEGER PRIMARY KEY AUTOINCREMENT,\\n\
             pns_name TEXT NOT NULL UNIQUE,\\n\
             created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n\
         );\\n\
         \\n\
         CREATE TABLE IF NOT EXISTS keyval_ns (\\n\
             id INTEGER PRIMARY KEY AUTOINCREMENT,\\n\
             project_id INTEGER NOT NULL,\\n\
             kvns_name TEXT NOT NULL,\\n\
             created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\n\
             FOREIGN KEY (project_id) REFERENCES project_ns(id) ON DELETE CASCADE,\\n\
             UNIQUE(project_id, kvns_name)\\n\
         );\\n\
         \\n\
         CREATE TABLE IF NOT EXISTS keyval (\\n\
             id INTEGER PRIMARY KEY AUTOINCREMENT,\\n\
             keyval_ns_id INTEGER NOT NULL,\\n\
             key TEXT NOT NULL,\\n\
             value TEXT NOT NULL,\\n\
             created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\n\
             updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\n\
             FOREIGN KEY (keyval_ns_id) REFERENCES keyval_ns(id) ON DELETE CASCADE,\\n\
             UNIQUE(keyval_ns_id, key)\\n\
         );\";\n\
         \n\
         pub const RESOLVE_PROJECT_ID: &str = \"SELECT id FROM project_ns WHERE pns_name = ?1;\";\n\
         pub const GET_VARIABLE: &str = \"SELECT value FROM keyval WHERE keyval_ns_id = ?1 AND key = ?2;\";\n\
         pub const SET_VARIABLE: &str = \"INSERT OR REPLACE INTO keyval (keyval_ns_id, key, value, updated_at) VALUES (?1, ?2, ?3, datetime('now'));\";\n",
        sql_version
    );

    fs::write(out_path, fallback_content)?;
    Ok(())
}

